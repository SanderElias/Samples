import{a as H}from"./chunk-DHJAG7LQ.js";import{Jc as g,Kc as T,Lc as D,Vc as I,ba as v,ga as b,ka as C,p as j,pa as k,r as w,ra as E,xa as h}from"./chunk-UTYHTRAX.js";import{a as m,b as O}from"./chunk-DAQOROHW.js";var U=e=>e==null?!1:e&&typeof e[Symbol.asyncIterator]=="function",N=e=>typeof e?.then=="function",Q=(e,s,t)=>{let r=h({value:s,error:void 0});try{t=t??b(E)}catch{if(!t)throw new Error("[asyncComputed] destroyRef is mandatory when used outside a injection context");if(!(t instanceof E))throw new Error("[asyncComputed] parameter destroyRef is not a DestroyRef")}let n,o,a=()=>(o?.unsubscribe(),n?.abort()),i=c=>{if(c.aborted)throw new Error("aborted")};t.onDestroy(()=>{a(),d.destroy()});let d=T(async c=>{c(a);try{n=new AbortController;let l=n.signal,u=e(l);if(i(l),j(u))o=u.subscribe({next:f=>{i(l),r.set({value:f})},error:f=>{i(l),r.set({error:f})}});else if(N(u)){let f=await u;i(l),r.set({value:f})}else if(U(u))for await(let f of u)i(l),r.set({value:f});else r.set({value:u})}catch(l){l.message!=="aborted"&&r.set({error:l})}},{manualCleanup:!0,debugName:"asyncComputed"});return g(()=>{let c=r();if(c.error)throw I()&&console.warn(`
  [asyncComputed] error: ${c.error.message}
    The error was thrown inside the callback function. The best way to handle
    this error is  inside that function. However, asyncComputed will rethrow
    the error to make sure that the error is not silently ignored.
    The error will be reset when one of the signals inside the function changes.
    Until that happens, the error will be re-thrown by Angular on every use
    of the signal. (usually every change detection cycle)
    (this warning is only shown in dev mode)
`),c.error;return c.value})},X=(e,s,t)=>{let r=h({value:s,error:void 0,status:"init",stream:"init"}),n=u=>r.update(f=>m(m({},f),u));try{t=t??b(E)}catch{if(!t)throw new Error("[asyncComputed] destroyRef is mandatory when used outside a injection context");if(!(t instanceof E))throw new Error("[asyncComputed] parameter destroyRef is not a DestroyRef")}let o,a,i=()=>(a?.unsubscribe(),o?.abort()),d=u=>{if(u.aborted)throw new Error("aborted")};t.onDestroy(()=>{i(),c.destroy()});let c=T(async u=>{u(i),n({status:"triggered"});try{o=new AbortController;let f=o.signal,y=e(f);if(d(f),n({status:"loading",stream:"init"}),j(y))n({stream:"ongoing"}),a=y.subscribe({next:p=>{d(f),r.update(B=>O(m({},B),{value:p,error:void 0,status:"awaiting"}))},error:p=>{d(f),n({error:p,value:void 0,status:"error",stream:"done"})},complete:()=>{d(f),n({stream:"done"})}});else if(N(y)){let p=await y;d(f),n({value:p,error:void 0,status:"loaded",stream:"done"})}else if(U(y)){n({stream:"ongoing"});for await(let p of y)d(f),n({value:p,error:void 0,status:"awaiting"});n({stream:"done"})}else n({value:y,error:void 0,status:"loaded",stream:"done"})}catch(f){f.message!=="aborted"&&n({error:f})}},{manualCleanup:!0}),l=D({source:()=>r().value,computation:u=>u});return g(()=>{let u=r();return{value:l,error:u.error,status:u.status,stream:u.stream}})},G=(e,s)=>{let t,r,n=s.delay||500,o=h(0);return D({source:()=>({value:e(),time:o()}),computation:({value:i,time:d})=>(d===0&&(r=i),t||(t=Date.now()+n,setTimeout(()=>o.set(d+1),n+1)),t<Date.now()&&(r=i,t=void 0),r),equal:s.equal})},Y=(e,s)=>G(e,s).asReadonly(),P=class{constructor(){this.promise=new Promise((s,t)=>{this.resolve=s,this.reject=t})}},L=(e=b(k))=>(s,t)=>C(e,()=>z(s,t)),z=(e,s)=>{let t=new P,r=T(n=>{let o=e();try{s(o)&&(t.resolve(o),r.destroy())}catch(a){t.reject(a),r.destroy()}n(()=>{t.reject(new Error("[awaitSignal] the provided signal was destroyed before the predicate was satisfied"))})},{debugName:"awaitSignal"});return t.promise};var Z=(()=>{class e{constructor(){this.#t=b(H),this.#e={DELETE:h(0),HEAD:h(0),PATCH:h(0),POST:h(0),PUT:h(0),GET:h(0)},this.busyMethods={DELETE:g(()=>this.#e.DELETE()!==0),HEAD:g(()=>this.#e.HEAD()!==0),PATCH:g(()=>this.#e.PATCH()!==0),POST:g(()=>this.#e.POST()!==0),PUT:g(()=>this.#e.PUT()!==0),GET:g(()=>this.#e.GET()!==0)},this.isBusy=g(()=>Object.values(this.#e).some(t=>t()!==0)),this.#n=L(),this.#r=async(t,r)=>{await this.#n(this.#e[t],n=>n===0),this.#e[t].update(n=>n+1);try{return await r}finally{this.#e[t].update(n=>n-1)}}}#t;#e;#n;#r;delete(t,r={}){return this.#r("DELETE",w(this.#t.delete(t,r)))}head(t,r){return this.#r("HEAD",w(this.#t.head(t,r)))}patch(t,r,n){return this.#r("PATCH",w(this.#t.patch(t,r,n)))}post(t,r,n={}){return this.#r("POST",w(this.#t.post(t,r,n)))}put(t,r,n={}){return this.#r("PUT",w(this.#t.put(t,r,n)))}get(t,r={}){return this.#r("GET",w(this.#t.get(t,r)))}static{this.\u0275fac=function(r){return new(r||e)}}static{this.\u0275prov=v({token:e,factory:e.\u0275fac,providedIn:"root"})}}return e})();function F(e){return typeof e?.getMonth=="function"}var A=(e,s=new Map)=>{if(e===null||typeof e!="object")return e;if(F(e))return new Date(e.getTime());if(s.has(e))return s.get(e);let t=n=>A(n,s);if(e instanceof RegExp){let n=new RegExp(e.source,e.flags);return n.lastIndex=e.lastIndex,s.set(e,n),n}if(e instanceof Set){let n=new Set;return s.set(e,n),[...e].forEach(o=>n.add(t(o))),n}if(e instanceof Map){let n=new Map;return s.set(e,n),[...e.entries()].forEach(o=>n.set(t(o[0]),t(o[1]))),n}if(Array.isArray(e)){let n=new Array(e.length);return s.set(e,n),e.forEach((o,a)=>n[a]=t(o)),n}let r=m({},e);s.set(e,r);for(let[n,o]of Object.entries(r))o!==null&&typeof o=="object"&&(r[n]=t(o));return r};function M(e,s){if(e===s)return!0;if(e&&s&&typeof e=="object"&&typeof s=="object"){if(e.constructor!==s.constructor)return!1;let t,r;if(Array.isArray(e)){if(!Array.isArray(s)||(t=e.length,t!=s.length))return!1;for(r=t;r--!==0;)if(!M(e[r],s[r]))return!1;return!0}if(e instanceof Map&&s instanceof Map){if(e.size!==s.size)return!1;for(r of e.entries())if(!s.has(r[0]))return!1;for(r of e.entries())if(!M(r[1],s.get(r[0])))return!1;return!0}if(e instanceof Set&&s instanceof Set){if(e.size!==s.size)return!1;for(r of e.entries())if(!s.has(r[0]))return!1;return!0}if(e instanceof Date&&s instanceof Date)return e.getTime()===s.getTime();if(ArrayBuffer.isView(e)&&ArrayBuffer.isView(s)){if(t=e.length,t!=s.length)return!1;for(r=t;r--!==0;)if(e[r]!==s[r])return!1;return!0}if(e.constructor===RegExp)return e.source===s.source&&e.flags===s.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===s.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===s.toString();let n=Object.keys(e);if(t=n.length,t!==Object.keys(s).length)return!1;for(r=t;r--!==0;)if(!Object.prototype.hasOwnProperty.call(s,n[r]))return!1;for(r=t;r--!==0;){let o=n[r];if(!M(e[o],s[o]))return!1}return!0}return e!==e&&s!==s}var x=e=>{let s=parseInt(e,10);return!isNaN(s)&&`${s}`===e},S=e=>!(typeof e!="object"||e===null||Array.isArray(e)||F(e)),R=(e,s,t={},r=[])=>{let n=i=>typeof t.iterableMergeStrategy=="function"?t.iterableMergeStrategy(i):t.iterableMergeStrategy??"concat",o=t.skipAssignUndefined??!1;if(!(Array.isArray(e)||S(e))||!(Array.isArray(s)||S(s)))throw new Error("[deepMergeObjects] target and source must be objects or arrays");let a=A(e);for(let[i,d]of Object.entries(s)){let c=d,l=a[i];if(o&&c===void 0)continue;let u=[...r,i];if(Array.isArray(c))switch(n(u)){case"concat":{a[i]=(l??[]).concat(c);break}case"replace":{a[i]=A(c);break}case"merge":{a[i]=V(l??[],c,t,u);break}}else if(c instanceof Set)if(n(u)==="replace"||l===void 0)a[i]=new Set(c);else{if(!(l instanceof Set))throw new Error("[deepMergeObjects] Cannot merge or concat a Set with a non-Set");a[i]=new Set([...l,...c])}else if(c instanceof Map)if(n(u)==="replace"||l===void 0)a[i]=new Map(c);else{if(!(l instanceof Map))throw new Error("[deepMergeObjects] Cannot merge or concat a Map with a non-Map");a[i]=new Map([...l,...c])}else S(c)?a[i]=R(S(l)?l:{},c,t,u):c instanceof Date?a[i]=new Date(c):a[i]=c}return a},V=(e,s,t={},r=[])=>{let n=e.reduce((o,a,i)=>(o[i]=A(a),o),[]);return s.forEach((o,a)=>{let i=n[a];Array.isArray(o)?i=V(i??[],o,t,r):S(o)?i=R(i??{},o,t,r):i=A(o),n[a]=i}),n};export{Q as a,X as b,Y as c,Z as d,M as e,x as f,S as g,R as h};
