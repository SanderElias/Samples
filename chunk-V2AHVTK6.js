import{a as C,db as g,ga as p,la as V,o as k,qc as I,ta as v,uc as y,vc as L,wa as q,wc as w,xc as S}from"./chunk-AULJCTBB.js";import{a as b,b as T}from"./chunk-KAT7YFEL.js";var x=o=>o&&typeof o[Symbol.asyncIterator]=="function",A=o=>typeof o?.then=="function",M=(o,t,e)=>{let a=g({value:t,error:void 0});try{e=e??p(v)}catch{if(!e)throw new Error("[asyncComputed] destroyRef is mandatory when used outside a injection context");if(!(e instanceof v))throw new Error("[asyncComputed] parameter destroyRef is not a DestroyRef")}let r,l,m=()=>(l?.unsubscribe(),r?.abort()),d=i=>{if(i.aborted)throw new Error("aborted")};e.onDestroy(()=>{m(),c.destroy()});let c=S(async i=>{i(m);try{r=new AbortController;let u=r.signal,s=o(u);if(d(u),k(s))l=s.subscribe({next:n=>{d(u),a.set({value:n})},error:n=>{d(u),a.set({error:n})}});else if(A(s)){let n=await s;d(u),a.set({value:n})}else if(x(s))for await(let n of s)d(u),a.set({value:n});else a.set({value:s})}catch(u){u.message!=="aborted"&&a.set({error:u})}},{manualCleanup:!0,forceRoot:!0});return y(()=>{let i=a();if(i.error)throw I()&&console.warn(`
  [asyncComputed] error: ${i.error.message}
    The error was thrown inside the callback function. The best way to handle
    this error is  inside that function. However, asyncComputed will rethrow
    the error to make sure that the error is not silently ignored.
    The error will be reset when one of the signals inside the function changes.
    Until that happens, the error will be re-thrown by Angular on every use
    of the signal. (usually every change detection cycle)
    (this warning is only shown in dev mode)
`),i.error;return i.value})},N=(o,t,e)=>{let a=g({value:t,error:void 0,status:"init",stream:"init"}),r=s=>a.update(n=>b(b({},n),s));try{e=e??p(v)}catch{if(!e)throw new Error("[asyncComputed] destroyRef is mandatory when used outside a injection context");if(!(e instanceof v))throw new Error("[asyncComputed] parameter destroyRef is not a DestroyRef")}let l,m,d=()=>(m?.unsubscribe(),l?.abort()),c=s=>{if(s.aborted)throw new Error("aborted")};e.onDestroy(()=>{d(),i.destroy()});let i=S(async s=>{s(d),r({status:"triggered"});try{l=new AbortController;let n=l.signal,h=o(n);if(c(n),r({status:"loading",stream:"init"}),k(h))r({stream:"ongoing"}),m=h.subscribe({next:f=>{c(n),a.update(D=>T(b({},D),{value:f,error:void 0,status:"awaiting"}))},error:f=>{c(n),r({error:f,value:void 0,status:"error",stream:"done"})},complete:()=>{c(n),r({stream:"done"})}});else if(A(h)){let f=await h;c(n),r({value:f,error:void 0,status:"loaded",stream:"done"})}else if(x(h)){r({stream:"ongoing"});for await(let f of h)c(n),r({value:f,error:void 0,status:"awaiting"});r({stream:"done"})}else r({value:h,error:void 0,status:"loaded",stream:"done"})}catch(n){n.message!=="aborted"&&r({error:n})}},{manualCleanup:!0,forceRoot:!0}),u=L({source:()=>a().value,computation:s=>s});return y(()=>{let s=a();return{value:u,error:s.error,status:s.status,stream:s.stream}})};function j(o){o?.injector||V(j);let t=o.request??(()=>null);return new E(t,o.loader,o.equal,o.injector)}var P=class{constructor(t){this.status=g("idle"),this.error=g(void 0),this.value=g(void 0,{equal:t?F(t):void 0}),this.rawSetValue=this.value.set,this.value.set=e=>this.set(e),this.value.update=e=>this.set(e(w(this.value)))}set(t){let e=this.value[C].version;this.rawSetValue(t),this.value[C].version!==e&&(this.onLocalValue(),this.status.set("local"),this.error.set(void 0))}isLoading(){return this.status()==="loading"||this.status()==="refreshing"}hasValue(){return this.status()==="resolved"||this.status()==="local"}asReadonly(){return this}setValueState(t,e=void 0){this.status.set(t),this.rawSetValue(e),this.error.set(void 0)}setErrorState(t){this.status.set("error"),this.value.set(void 0),this.error.set(t)}},E=class extends P{constructor(t,e,a,r){super(a),this.loaderFn=e,this.resolvePendingTask=void 0,this.pendingTasks=r?.get(q)??p(q),this.request=y(()=>({request:t(),refresh:g(0)})),S(this.loadEffect.bind(this),{injector:r})}refresh(){let t=w(this.status);return t==="loading"||t==="refreshing"?!1:(w(this.request).refresh.update(e=>e+1),!0)}async loadEffect(){let t=w(this.status);this.abortInProgessLoad();let e=this.request();if(e.request===void 0){this.setValueState("idle");return}this.status.set(e.refresh()===0?"loading":"refreshing");let a=this.resolvePendingTask=this.pendingTasks.add(),{signal:r}=this.pendingController=new AbortController;try{let l=await w(()=>this.loaderFn({abortSignal:r,request:e.request,previous:{status:t}}));if(r.aborted)return;this.setValueState("resolved",l)}catch(l){if(r.aborted)return;this.setErrorState(l)}finally{a()}}abortInProgessLoad(){this.pendingController?.abort(),this.pendingController=void 0,this.resolvePendingTask?.(),this.resolvePendingTask=void 0}onLocalValue(){this.abortInProgessLoad()}};function F(o){return(t,e)=>t===void 0||e===void 0?t===e:o(t,e)}export{M as a,N as b,j as c};
